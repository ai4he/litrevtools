/**
 * LaTeX research paper generator
 */

import { Paper, PRISMAData, SearchParameters } from '../types';
import { GeminiService } from '../gemini';
import * as fs from 'fs';
import * as path from 'path';

export class LaTeXGenerator {
  private gemini: GeminiService;

  constructor(gemini: GeminiService) {
    this.gemini = gemini;
  }

  /**
   * Generate complete LaTeX research paper
   */
  async generate(
    papers: Paper[],
    searchParams: SearchParameters,
    prismaData: PRISMAData,
    outputPath: string
  ): Promise<string> {
    // Generate content sections using Gemini
    const abstract = await this.gemini.generateAbstract(
      papers,
      searchParams.inclusionKeywords,
      prismaData
    );

    const introduction = await this.gemini.generateIntroduction(
      papers,
      searchParams.inclusionKeywords
    );

    const methodology = await this.gemini.generateMethodology(
      searchParams.inclusionKeywords,
      searchParams.inclusionKeywords,
      searchParams.exclusionKeywords,
      prismaData
    );

    const results = await this.gemini.generateResults(papers);

    const discussion = await this.gemini.generateDiscussion(
      papers,
      searchParams.inclusionKeywords
    );

    const conclusion = await this.gemini.generateConclusion(
      papers,
      searchParams.inclusionKeywords
    );

    // Build LaTeX document
    const latex = this.buildLaTeXDocument({
      title: this.generateTitle(searchParams.inclusionKeywords),
      abstract,
      introduction,
      methodology,
      results,
      discussion,
      conclusion,
      searchParams,
      prismaData
    });

    // Ensure directory exists
    const dir = path.dirname(outputPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    // Write to file
    fs.writeFileSync(outputPath, latex, 'utf-8');

    return outputPath;
  }

  /**
   * Build complete LaTeX document
   */
  private buildLaTeXDocument(content: {
    title: string;
    abstract: string;
    introduction: string;
    methodology: string;
    results: string;
    discussion: string;
    conclusion: string;
    searchParams: SearchParameters;
    prismaData: PRISMAData;
  }): string {
    return `\\documentclass[12pt,a4paper]{article}

% Packages
\\usepackage[utf8]{inputenc}
\\usepackage[T1]{fontenc}
\\usepackage{geometry}
\\usepackage{graphicx}
\\usepackage{booktabs}
\\usepackage{hyperref}
\\usepackage{natbib}
\\usepackage{amsmath}
\\usepackage{amssymb}
\\usepackage{float}
\\usepackage{caption}

% Page layout
\\geometry{margin=1in}

% Hyperref setup
\\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    citecolor=blue,
}

% Title and authors
\\title{${this.escapeLatex(content.title)}}
\\author{Generated by LitRevTools}
\\date{\\today}

\\begin{document}

\\maketitle

% Abstract
\\begin{abstract}
${this.escapeLatex(content.abstract)}
\\end{abstract}

\\newpage
\\tableofcontents
\\newpage

% Introduction
\\section{Introduction}
${this.escapeLatex(content.introduction)}

% Methodology
\\section{Methodology}
${this.escapeLatex(content.methodology)}

\\subsection{PRISMA Flow}
The systematic review process followed the PRISMA (Preferred Reporting Items for Systematic Reviews and Meta-Analyses) guidelines. Figure~\\ref{fig:prisma} shows the flow diagram of the study selection process.

\\begin{figure}[H]
\\centering
\\caption{PRISMA flow diagram}
\\label{fig:prisma}
\\textit{[PRISMA diagram should be included here]}
\\end{figure}

% Results
\\section{Results}
${this.escapeLatex(content.results)}

${this.generatePRISMATable(content.prismaData)}

% Discussion
\\section{Discussion}
${this.escapeLatex(content.discussion)}

% Conclusion
\\section{Conclusion}
${this.escapeLatex(content.conclusion)}

% References
\\bibliographystyle{plain}
\\bibliography{references}

\\end{document}
`;
  }

  /**
   * Generate PRISMA summary table in LaTeX
   */
  private generatePRISMATable(prismaData: PRISMAData): string {
    return `
\\subsection{PRISMA Summary}

Table~\\ref{tab:prisma} summarizes the PRISMA flow statistics.

\\begin{table}[H]
\\centering
\\caption{PRISMA Flow Statistics}
\\label{tab:prisma}
\\begin{tabular}{lr}
\\toprule
\\textbf{Stage} & \\textbf{Count} \\\\
\\midrule
Records identified & ${prismaData.identification.recordsIdentified} \\\\
Records removed (duplicates, etc.) & ${prismaData.identification.recordsRemoved} \\\\
Records screened & ${prismaData.screening.recordsScreened} \\\\
Records excluded & ${prismaData.screening.recordsExcluded} \\\\
Studies included in review & ${prismaData.included.studiesIncluded} \\\\
\\bottomrule
\\end{tabular}
\\end{table}

${this.generateExclusionReasonsTable(prismaData)}
`;
  }

  /**
   * Generate exclusion reasons table
   */
  private generateExclusionReasonsTable(prismaData: PRISMAData): string {
    const reasons = prismaData.screening.reasonsForExclusion;
    const entries = Object.entries(reasons);

    if (entries.length === 0) {
      return '';
    }

    const rows = entries.map(([reason, count]) =>
      `${this.escapeLatex(reason)} & ${count} \\\\`
    ).join('\n');

    return `
\\begin{table}[H]
\\centering
\\caption{Reasons for Exclusion}
\\label{tab:exclusion}
\\begin{tabular}{lr}
\\toprule
\\textbf{Reason} & \\textbf{Count} \\\\
\\midrule
${rows}
\\bottomrule
\\end{tabular}
\\end{table}
`;
  }

  /**
   * Generate title from keywords
   */
  private generateTitle(keywords: string[]): string {
    const keywordPhrase = keywords.slice(0, 3).join(', ');
    return `A Systematic Literature Review on ${keywordPhrase}`;
  }

  /**
   * Escape special LaTeX characters
   */
  private escapeLatex(text: string): string {
    return text
      .replace(/\\/g, '\\textbackslash{}')
      .replace(/&/g, '\\&')
      .replace(/%/g, '\\%')
      .replace(/\$/g, '\\$')
      .replace(/#/g, '\\#')
      .replace(/_/g, '\\_')
      .replace(/\{/g, '\\{')
      .replace(/\}/g, '\\}')
      .replace(/~/g, '\\textasciitilde{}')
      .replace(/\^/g, '\\textasciicircum{}');
  }
}
